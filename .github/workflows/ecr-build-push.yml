name: Build and Push Flask App to ECR

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  ECR_REPOSITORY: ${{ secrets.REPO_NAME }} # ¡IMPORTANTE! Reemplaza con el nombre exacto de tu repositorio ECR en AWS
  SERVICE_NAME: web # Nombre del servicio en tu docker-compose.yml que quieres construir
  IMAGE_TAG: latest # Etiqueta principal de la imagen (ej. 'latest'). Puedes usar ${{ github.sha }} para el hash del commit.
  # Nueva variable para el URI base de ECR
  # Se poblará en el paso de login para asegurar que es el correcto
  ECR_REGISTRY_URI: "" # Dejar vacío, se llenará con la salida del login

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx (and Docker Compose)
        uses: docker/setup-buildx-action@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
        # Captura la URL completa del registro ECR en una variable de entorno
        # para que esté disponible en los pasos siguientes.
        # Esto asegura que tengas el prefijo correcto para el nombre de la imagen.
      - name: Set ECR Registry URI
        run: echo "ECR_REGISTRY_URI=${{ steps.login-ecr.outputs.registry }}" >> $GITHUB_ENV

      - name: Build and Push Docker image to ECR
        run: |
          # Define el URI completo de la imagen ECR usando la variable de entorno
          # que ahora tiene el prefijo de tu registro ECR.
          ECR_FULL_IMAGE_URI="${{ env.ECR_REGISTRY_URI }}/${{ env.ECR_REPOSITORY }}:${{ env.IMAGE_TAG }}"
          ECR_FULL_IMAGE_URI_SHA="${{ env.ECR_REGISTRY_URI }}/${{ env.ECR_REPOSITORY }}:${{ github.sha }}"

          # Construye la imagen directamente con el nombre de destino de ECR.
          # Usamos --build-arg o podemos pasar un tag directamente si tu docker-compose.yml lo soporta.
          # La forma más directa es construirla y luego etiquetarla con el nombre completo.
          # Sin embargo, si docker-compose build no etiqueta con un nombre útil,
          # es mejor usar 'docker build' o asegurar que 'docker compose build' lo haga.

          # Volvamos a la estrategia de etiquetar, pero asegurándonos de que Docker Compose
          # construya una imagen con un nombre predecible.
          # Por defecto, docker-compose build crea una imagen con el formato
          # <nombre_directorio_proyecto>_<nombre_servicio>
          # Podemos forzar el nombre de la imagen en el docker-compose.yml para que sea directo.
          # Primero, modificaremos el docker-compose.yml ligeramente.

          # PASO INTERMEDIO: Modifica tu docker-compose.yml para especificar el nombre de la imagen
          # Antes de este paso en GitHub Actions, asegura que tu docker-compose.yml tenga esto:
          # services:
          #   web:
          #     build: .
          #     image: ${ECR_REGISTRY_URI}/${ECR_REPOSITORY}:${IMAGE_TAG} # <-- AÑADE ESTO (o similar)
          #     ports:
          #       - "8000:8000"
          #     restart: always
          #
          # Con esta modificación en docker-compose.yml, el build ya creará la imagen con el nombre esperado.

          # --- Nuevo comando de construcción, ahora la imagen ya tiene el nombre de ECR ---
          # Asegúrate que las variables de entorno ECR_REGISTRY_URI, ECR_REPOSITORY y IMAGE_TAG
          # estén disponibles para docker-compose. Las pasamos explícitamente.
          docker compose build ${{ env.SERVICE_NAME }} \
            --build-arg ECR_REGISTRY_URI="${{ env.ECR_REGISTRY_URI }}" \
            --build-arg ECR_REPOSITORY="${{ env.ECR_REPOSITORY }}" \
            --build-arg IMAGE_TAG="${{ env.IMAGE_TAG }}"

          # Una vez construida, solo necesitamos re-etiquetar para la versión con SHA y luego empujar
          # El nombre de la imagen local debería ser ahora ECR_FULL_IMAGE_URI
          docker tag ${ECR_FULL_IMAGE_URI} ${ECR_FULL_IMAGE_URI_SHA}

          docker push ${ECR_FULL_IMAGE_URI}
          docker push ${ECR_FULL_IMAGE_URI_SHA}
